#include "kernel/io/keyboard.h"
#include "kernel/debug/assert.h"
#include "kernel/interrupt/intr.h"
#include "kernel/io/io.h"
#include "kernel/io/video/print.h"

namespace io {

namespace {

//! *Intel 8042* registers.
namespace port {
//! The data register.
inline constexpr stl::uint16_t data {0x60};
//! The status register.
inline constexpr stl::uint16_t status {0x64};
//! The control register.
inline constexpr stl::uint16_t ctrl {0x64};
}  // namespace port

//! Scan codes.
namespace sc {
//! A prefix indicating that the current scan code contains multiple bytes.
inline constexpr stl::uint8_t ext_leader {0xE0};

//! Make codes.
namespace mk {

//! The make code for the left @p Shift.
inline constexpr stl::uint8_t shift_left {0x2A};
//! The make code for the right @p Shift.
inline constexpr stl::uint8_t shift_right {0x36};
//! The make code for the left @p Alt.
inline constexpr stl::uint8_t alt_left {0x38};
//! The make code for the right @p Alt.
inline constexpr stl::uint16_t alt_right {bit::CombineBytes(ext_leader, alt_left)};
//! The make code for the left @p Ctrl.
inline constexpr stl::uint8_t ctrl_left {0x1D};
//! The make code for the right @p Ctrl.
inline constexpr stl::uint16_t ctrl_right {bit::CombineBytes(ext_leader, ctrl_left)};
//! The make code for @p Caps-Lock.
inline constexpr stl::uint8_t caps_lock {0x3A};

}  // namespace mk

}  // namespace sc

/**
 * The scan code generated by a key when it is pressed or released.
 */
class ScanCode {
public:
    constexpr ScanCode(const stl::uint16_t code = 0) noexcept : code_ {code} {}

    /**
     * @brief Whether the scan code is a break code.
     *
     * @details
     * When a key is pressed, it keeps generating make codes.
     * When a key is released, it generates a break code.
     */
    constexpr bool IsBreakCode() const noexcept {
        return bit::IsBitSet(code_, break_pos);
    }

    constexpr stl::uint16_t GetMakeCode() const noexcept {
        if (IsBreakCode()) {
            auto make_code {code_};
            bit::ResetBit(make_code, break_pos);
            return make_code;
        } else {
            return code_;
        }
    }

    constexpr operator stl::uint16_t() const noexcept {
        return code_;
    }

private:
    //! A bit in a one-byte scan code indicating whether it is a break code.
    static constexpr stl::size_t break_pos {7};

    stl::uint16_t code_;
};

class KeyHandler {
public:
    KeyHandler(KeyboardBuffer& buf) noexcept : buf_ {buf} {}

    //! Process a scan code and push a character into the keyboard buffer.
    void Enter(const stl::uint8_t scan_code) noexcept {
        if (scan_code == sc::ext_leader) {
            // Wait for the next byte if the scan code contains multiple bytes.
            is_ext_scan_code_ = true;
            return;
        }

        ScanCode full_scan_code;
        if (is_ext_scan_code_) {
            // Combine the two bytes into a full scan code.
            full_scan_code = bit::CombineBytes(sc::ext_leader, scan_code);
            is_ext_scan_code_ = false;
        } else {
            full_scan_code = scan_code;
        }

        const auto make_code {full_scan_code.GetMakeCode()};
        if (full_scan_code.IsBreakCode()) {
            // The key is released.
            UpdateCtrlKeyStatus(make_code, false);
        } else if (IsSupportedKey(make_code)) {
            // The key is pressed.
            UpdateCtrlKeyStatus(make_code, true);
            const auto is_shift_enabled {IsShiftEnabled(make_code)};
            // Find the character according to the make code and shift status.
            const auto ch {
                key_map[bit::GetLowByte(make_code)][static_cast<stl::size_t>(is_shift_enabled)]};
            if (ch != '\0' && !buf_.IsFull()) {
                // Push the character into the keyboard buffer.
                buf_.Push(ch);
            }
        } else {
            io::PrintlnStr("The input key is unsupported.");
        }
    }

private:
    static constexpr char esc {'\033'};
    static constexpr char backspace {'\b'};
    static constexpr char tab {'\t'};
    static constexpr char enter {'\r'};
    static constexpr char del {'\177'};

    //! Use @p '\0' as placeholders to represent some control keys in make code maps.
    static constexpr char ctrl_left_char {'\0'};
    static constexpr char ctrl_right_char {'\0'};
    static constexpr char shift_left_char {'\0'};
    static constexpr char shift_right_char {'\0'};
    static constexpr char alt_left_char {'\0'};
    static constexpr char alt_right_char {'\0'};
    static constexpr char caps_lock_char {'\0'};

    //! Characters for each make code when shift is disabled or not.
    static constexpr char key_map[][2] {/* 0x00 */ {'\0', '\0'},
                                        /* 0x01 */ {esc, esc},
                                        /* 0x02 */ {'1', '!'},
                                        /* 0x03 */ {'2', '@'},
                                        /* 0x04 */ {'3', '#'},
                                        /* 0x05 */ {'4', '$'},
                                        /* 0x06 */ {'5', '%'},
                                        /* 0x07 */ {'6', '^'},
                                        /* 0x08 */ {'7', '&'},
                                        /* 0x09 */ {'8', '*'},
                                        /* 0x0A */ {'9', '('},
                                        /* 0x0B */ {'0', ')'},
                                        /* 0x0C */ {'-', '_'},
                                        /* 0x0D */ {'=', '+'},
                                        /* 0x0E */ {backspace, backspace},
                                        /* 0x0F */ {tab, tab},
                                        /* 0x10 */ {'q', 'Q'},
                                        /* 0x11 */ {'w', 'W'},
                                        /* 0x12 */ {'e', 'E'},
                                        /* 0x13 */ {'r', 'R'},
                                        /* 0x14 */ {'t', 'T'},
                                        /* 0x15 */ {'y', 'Y'},
                                        /* 0x16 */ {'u', 'U'},
                                        /* 0x17 */ {'i', 'I'},
                                        /* 0x18 */ {'o', 'O'},
                                        /* 0x19 */ {'p', 'P'},
                                        /* 0x1A */ {'[', '{'},
                                        /* 0x1B */ {']', '}'},
                                        /* 0x1C */ {enter, enter},
                                        /* 0x1D */ {ctrl_left_char, ctrl_left_char},
                                        /* 0x1E */ {'a', 'A'},
                                        /* 0x1F */ {'s', 'S'},
                                        /* 0x20 */ {'d', 'D'},
                                        /* 0x21 */ {'f', 'F'},
                                        /* 0x22 */ {'g', 'G'},
                                        /* 0x23 */ {'h', 'H'},
                                        /* 0x24 */ {'j', 'J'},
                                        /* 0x25 */ {'k', 'K'},
                                        /* 0x26 */ {'l', 'L'},
                                        /* 0x27 */ {';', ':'},
                                        /* 0x28 */ {'\'', '"'},
                                        /* 0x29 */ {'`', '~'},
                                        /* 0x2A */ {shift_left_char, shift_left_char},
                                        /* 0x2B */ {'\\', '|'},
                                        /* 0x2C */ {'z', 'Z'},
                                        /* 0x2D */ {'x', 'X'},
                                        /* 0x2E */ {'c', 'C'},
                                        /* 0x2F */ {'v', 'V'},
                                        /* 0x30 */ {'b', 'B'},
                                        /* 0x31 */ {'n', 'N'},
                                        /* 0x32 */ {'m', 'M'},
                                        /* 0x33 */ {',', '<'},
                                        /* 0x34 */ {'.', '>'},
                                        /* 0x35 */ {'/', '?'},
                                        /* 0x36 */ {shift_right_char, shift_right_char},
                                        /* 0x37 */ {'*', '*'},
                                        /* 0x38 */ {alt_left_char, alt_left_char},
                                        /* 0x39 */ {' ', ' '},
                                        /* 0x3A */ {caps_lock_char, caps_lock_char}};

    void UpdateCtrlKeyStatus(const stl::uint16_t make_code, const bool pressed) noexcept {
        dbg::Assert(!ScanCode {make_code}.IsBreakCode());
        if (make_code == sc::mk::ctrl_left || make_code == sc::mk::ctrl_right) {
            ctrl_pressed_ = pressed;
        } else if (make_code == sc::mk::shift_left || make_code == sc::mk::shift_right) {
            shift_pressed_ = pressed;
        } else if (make_code == sc::mk::alt_left || make_code == sc::mk::alt_right) {
            alt_pressed_ = pressed;
        } else if (pressed && make_code == sc::mk::caps_lock) {
            caps_lock_enabled_ = !caps_lock_enabled_;
        }
    }

    bool IsSupportedKey(const stl::uint16_t make_code) const noexcept {
        dbg::Assert(!ScanCode {make_code}.IsBreakCode());
        return (0 < make_code && make_code < sizeof(key_map) / (sizeof(char) * 2))
               || make_code == sc::mk::alt_right || make_code == sc::mk::ctrl_right;
    }

    bool IsShiftEnabled(const stl::uint16_t make_code) const noexcept {
        dbg::Assert(IsSupportedKey(make_code));
        const auto ch {key_map[bit::GetLowByte(make_code)][0]};
        if (('0' <= ch && ch <= '9') || ch == '-' || ch == '=' || ch == '`' || ch == '['
            || ch == ']' || ch == '\\' || ch == ';' || ch == '\'' || ch == ',' || ch == '.'
            || ch == '/') {
            return shift_pressed_;
        } else if (shift_pressed_ && caps_lock_enabled_) {
            return false;
        } else if (shift_pressed_ || caps_lock_enabled_) {
            return true;
        } else {
            return false;
        }
    }

    //! Whether @p Ctrl is pressed.
    bool ctrl_pressed_ {false};
    //! Whether @p Alt is pressed.
    bool alt_pressed_ {false};
    //! Whether @p Shift is pressed.
    bool shift_pressed_ {false};
    //! Whether @p Caps-Lock is pressed.
    bool caps_lock_enabled_ {false};
    //! Whether the current scan code contains multiple bytes.
    bool is_ext_scan_code_ {false};

    KeyboardBuffer& buf_;
};

/**
 * The keyboard interrupt handler.
 * It reads pressed keys and processes them.
 */
void KeyboardIntrHandler(stl::size_t) noexcept {
    static KeyHandler handler {GetKeyboardBuffer()};
    const auto scan_code {io::ReadByteFromPort(port::data)};
    handler.Enter(scan_code);
}

}  // namespace

KeyboardBuffer& GetKeyboardBuffer() noexcept {
    static KeyboardBuffer buf;
    return buf;
}

void InitKeyboard() noexcept {
    intr::GetIntrHandlerTab().Register(intr::Intr::Keyboard, &KeyboardIntrHandler);
    io::PrintStr("The keyboard has been initialized.\n");
}

}  // namespace io